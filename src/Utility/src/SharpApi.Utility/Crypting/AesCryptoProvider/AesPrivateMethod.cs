using System;
using System.IO;
using System.Security.Cryptography;

namespace SharpApi.Utility.Crypting
{
    public partial class AesCryptoProvider
    {
        /// <summary>
        /// Gets the KeySize by the password length in bytes.
        /// </summary>
        /// <param name="passPhrase"></param>
        /// <returns></returns>
        private static int GetAesKeySize(string passPhrase)
        {
            switch (passPhrase.Length)
            {
                case 16:
                    return 128;
                case 24:
                    return 192;
                case 32:
                    return 256;
                case 64:
                    return 512;
                default:
                    throw new NotSupportedException("ERROR: AES Password must be of 16, 24, 32 or 64 bits length!");
            }
        }

        /// <summary>
        /// Checks if salt must be used or not for the encryption/decryption.
        /// </summary>
        /// <returns></returns>
        private bool UseSalt()
        {
            // Use salt if the max salt value is greater than 0 and equal or greater than min salt length.
            return (_options.MaxSaltLength > 0 && _options.MaxSaltLength >= _options.MinSaltLength);
        }

        /// <summary>
        /// Adds an array of randomly generated bytes at the beginning of the
        /// array holding original plain text value.
        /// </summary>
        /// <param name="plainTextBytes">
        /// Byte array containing original plain text value.
        /// </param>
        /// <returns>
        /// Either original array of plain text bytes (if salt is not used) or a
        /// modified array containing a randomly generated salt added at the 
        /// beginning of the plain text bytes. 
        /// </returns>
        private byte[] AddSalt(byte[] plainTextBytes)
        {
            // Additional check
            if (!UseSalt()) return plainTextBytes;

            // Generate the salt.
            var saltBytes = GenerateSalt(_options.MinSaltLength, _options.MaxSaltLength);

            // Allocate array which will hold salt and plain text bytes.
            var plainTextBytesWithSalt = new byte[plainTextBytes.Length + saltBytes.Length];
            // First, copy salt bytes.
            Array.Copy(saltBytes, plainTextBytesWithSalt, saltBytes.Length);

            // Append plain text bytes to the salt value.
            Array.Copy(plainTextBytes, 0,
                plainTextBytesWithSalt, saltBytes.Length,
                plainTextBytes.Length);

            return plainTextBytesWithSalt;
        }


        /// <summary>
        /// Generates an array holding cryptographically strong bytes.
        /// </summary>
        /// <returns>
        /// Array of randomly generated bytes.
        /// </returns>
        /// <remarks>
        /// Salt size will be defined at random or exactly as specified by the
        /// minSlatLen and maxSaltLen parameters passed to the object constructor.
        /// The first four bytes of the salt array will contain the salt length
        /// split into four two-bit pieces.
        /// </remarks>
        private byte[] GenerateSalt(int minSaltLen, int maxSaltLen)
        {
            // We don't have the length, yet.
            var saltLen = 0;

            // If min and max salt values are the same, it should not be random.
            saltLen = minSaltLen == maxSaltLen ? minSaltLen
                : RandomGenerator.GetInt(minSaltLen, maxSaltLen);

            // Allocate byte array to hold our salt.
            var salt = new byte[saltLen];

            // Populate salt with cryptographically strong bytes.
            var rng = new RNGCryptoServiceProvider();

            rng.GetNonZeroBytes(salt);

            // Split salt length (always one byte) into four two-bit pieces and
            // store these pieces in the first four bytes of the salt array.
            salt[0] = (byte)((salt[0] & 0xfc) | (saltLen & 0x03));
            salt[1] = (byte)((salt[1] & 0xf3) | (saltLen & 0x0c));
            salt[2] = (byte)((salt[2] & 0xcf) | (saltLen & 0x30));
            salt[3] = (byte)((salt[3] & 0x3f) | (saltLen & 0xc0));

            return salt;
        }

    }
}
